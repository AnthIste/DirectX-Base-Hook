<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link href="../screen.css" rel="StyleSheet">
  <title>Writing documentation</title>
  <meta name="author" content="AnthIste">
  <meta http-equiv="content-language" content="en">
</head>
<body>

    <h1>DirectX 9 Base Hook</h1>
	
	<h2>Table of Contents</h2>

    <p><a href="#INTRODUCTION" target="body">1. Introduction</a></p>
	<p><a href="#USAGE" target="body">2. Usage</a></p>
	<p><a href="#METHODS" target="body">3. Different hook methods</a></p>
	<p><a href="#NORMAL" target="body">3.1 Normal</a></p>
	<p><a href="#RUNTIME" target="body">3.2 Runtime</a></p>
	<p><a href="#DYNAMIC" target="body">3.3 Dynamic</a></p>
	<p><a href="#STRUCTURES" target="body">4. Structures</a></p>
	<p><a href="#FUNCTIONS" target="body">5. Functions</a></p>
	<p><a href="#CODEFLOW" target="body">6. Code flow</a></p>
    </p>

	<a name="INTRODUCTION"></a>
    <h2>Introduction</h2>
    <p>
		This is a DirectX 9 hooking library that should work on ANY game that uses DirectX 9
		for its rendering, and should be able to be unloaded/loaded at ANY time. Quite a tall order :).
		Well if Fraps got it right, why cant we? Difference is, this is a code library that can be employed
		on any job that needs a DirectX hook with as little effort as possible.
    </p>
	
	<a name="USAGE"></a>
    <h2>Usage</h2>
    <p>
		This library is supposed to be easy to use. All that is needed by the user is:
	</p>
	<p>
		<li>A detour function for whatever they want to hook (eg. <code>hook_EndScene</code>)</ul>
		<li>A pointer to hold the original function (eg. <code>pfnEndScene</code>)</ul>
		<li>A call to <code>DirectX9Detour</code></ul>
		<li>A call to the cleanup code, <code>FreeLists</code></ul>
	</p>
	<p>
		The library makes use of a vtable hook, so the function offset in the vtable needs to be specified. This is a simple matter, however, 
		as there are enumerations for the function offsets of all DirectX functions. As en example, the offset of <code>EndScene</code> would 
		be specified by the <code>ENDSCENE</code> enumeration.
    </p>
	<p>
		There are some objects that are allocated on the heap that must be freed when the user is done with the library. A call to 
		<code>FreeLists</code> is all that is necessary.
    </p>
	<p>
		Example usage:
	</p>
	<code><pre>
	// DirectX9 Hook by AnthIste and illuz1oN (C) 2010,
	// Contact us at illuz1oN@hotmail.co.uk or anthiste.anthiste@gmail.com

	#include &lt;windows.h&gt;
	#include "dx9hook.h"

	// Pointer to original function
	HRESULT (APIENTRY *pfnEndScene)(IDirect3DDevice9 *pDevice);
	
	// Detour function
	HRESULT APIENTRY hook_EndScene(IDirect3DDevice9 *pDevice)
	{
		D3DRECT rec = { 0, 0, 20, 20 };                     
		pDevice->Clear(1, &rec, D3DCLEAR_TARGET, D3DCOLOR_XRGB(255, 255, 255), 0,  0); 

		return pfnEndScene(pDevice);
	}

	BOOL APIENTRY DllMain(HMODULE hInstance, DWORD dwReason, LPVOID lpReserved)
	{
		switch (dwReason) {
			case DLL_PROCESS_ATTACH:
				DisableThreadLibraryCalls((HMODULE)hInstance);
				
				// Specify the function offset, the detour and the pointer to the original
				DirectX9Detour(ENDSCENE, (FARPROC)&hook_EndScene, (FARPROC)&pfnEndScene);
				break;

			case DLL_PROCESS_DETACH:
				// Detours can be removed at any time
				RemoveDetour(ENDSCENE);
				
				// Cleanup code for the library is necessary
				FreeLists();
				break;
		}

		return TRUE;
	}
	</pre></code>


	<a name="METHODS"></a>
    <h2>3. Different hook methods</h3>

    <p>
    There are 3 different situations in which a request can be made to hook a DirectX function:
	<a href="#STANDARD" target="body">standard</a>, <a href="#RUNTIME" target="body">runtime</a> and 
	<a href="#DYNAMIC" target="body">dynamic</a>.
    </p>
	<p>
	Suppose the user injects their dll into a game of their choice. Now, <code>d3d9.dll</code> either IS or ISNT loaded.
	If it IS, there is always the possibility that the game has not run its initialization routines for 
	DirectX, in which case we can hook those routines and get access to the device's vtable. However, there 
	is also the possibility that the game HAS already set up DirectX, in which case the above method would be 
	useless. In that case, we need to do a RUNTIME hook. The current method for achieving this is via 
	code injection. if <code>d3d9.dll</code> ISNT loaded, then the best we can do is wait for it to get loaded and 
	work from there. This is where the DYNAMIC hook comes in. We wait for the target game to manually load the 
	DirectX libraries, and then treat it as a STANDARD hook.
	</p>
	<p>
	Because it is uncertain when exactly the device vtable will be found and therefore when the hooks will be made, a call to 
	<code>CDirectX9Hook::DetourDirectX</code> only stores information about the detour request. This information is then used 
	later depending on which hook was successful.
	</p>
	<p>
	This is checked by the detour function:
	</p>
	<pre><code>
	void DirectX9Detour( UINT uOffset, FARPROC pfnDetour, FARPROC pfnOrig )
	{
		// Build and store a detour request object
		Detour_t *newDetour = (Detour_t *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(Detour_t));
		if(!newDetour)
			return;

		newDetour->detour	= (DWORD *)pfnDetour;
		newDetour->orig		= (DWORD *)pfnOrig;
		newDetour->offset	= uOffset;
		newDetour->hooked	= FALSE;
		DetourList.push_back(newDetour);

		// If we do not already have the device vtable, we need to find it
		if(!pTable) {
			// So we check if the DirectX module has been loaded or not
			if(GetModuleHandle("d3d9.dll")) {
				// If it has, attempt a STANDARD hook and a RUNTIME hook. Whichever triggers first will apply the hooks
				*(FARPROC *)&pfnDirect3DCreate9 = (FARPROC)DetourFunction((LPBYTE)Direct3DCreate9, (LPBYTE)hook_Direct3DCreate9);	// STANDARD
				InsertDirectX9Cave();													// RUNTIME
			} else {
				InsertDynamicDetour("d3d9.dll", "Direct3DCreate9", (FARPROC)&hook_Direct3DCreate9);					// DYNAMIC
			}
		}
		else {
			// We do have the device vtable, just apply the requested hooks
			SetSheduledHooks();
		}
	}
	</code></pre>
	
	<h3>3.1 Standard hook</h3>
	<p>
		This is the most basic hook that is currently implemented. The dll needs to be injected very early (before <code>Direct3DCreate9</code> 
		is called). To accomplish this, use the provided injector's AutoInject function.
	</p>
	<p>
		The basic steps of this hook are:
		<li>
			<p>
				Hook <code>Direct3DCreate9</code> to gain access to the created <code>IDirect3D9</code> object
			</p>
			<p><pre><code>
				*(FARPROC *)&pfnDirect3DCreate9 = (FARPROC)DetourFunction((LPBYTE)Direct3DCreate9, (LPBYTE)hook_Direct3DCreate9);
				</code></pre>
			</p>
		</ul>
		<li>
			<p>
			Use a vtable hook on the <em>object</em> to hook <code>CreateDevice</code>
			</p>
			<p><pre><code>
				IDirect3D9 *__stdcall hook_Direct3DCreate9( UINT sdkVersion )
				{
					// Call the original function
					IDirect3D9 *iDirect3D9 = pfnDirect3DCreate9(sdkVersion); 

					// Ensure that the new hook is not applied twice
					static bool bHooked = false;
					
					// Get the IDirect3D9 object's vtable address
					pDxTable = (DWORD *)(*(DWORD *)((void *)iDirect3D9));
					
					// Hook CreateDevice
					if(pDxTable && !bHooked) {
						*(FARPROC *)&pfnCreateDevice = NewDetour((DWORD *)pDxTable, 16, (FARPROC)hook_CreateDevice);
						
						// Clean up (ie remove this detour)
						DetourRemove((LPBYTE)hook_Direct3DCreate9, (LPBYTE)pfnDirect3DCreate9);
						bHooked = !bHooked;
					}
					
					return iDirect3D9;
				}
			</code></pre></p>
		</ul>
		<li>
			<p>Use a vtable hook on the <em>device</em> to hook whatever the user requested</p>
			<p><pre><code>
				HRESULT __stdcall hook_CreateDevice( IDirect3D9* d3d, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS * pPresentationParameters, IDirect3DDevice9 ** ppReturnedDeviceInterface )
				{
					HRESULT hRes = pfnCreateDevice(d3d, Adapter, DeviceType, hFocusWindow, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface);

					static bool bHooked = false;

					if(!pTable && !bHooked) {
						pTable = (DWORD *)(*(DWORD *)((void *)*ppReturnedDeviceInterface));
						NewDetour((DWORD *)pDxTable, 16, (FARPROC)pfnCreateDevice);
						SetSheduledHooks();		
						bHooked = !bHooked;
					}

					return hRes;
				}
			</code></pre></p>
		</ul>
	</p>
	
	<h3>3.2 Runtime hook</h3>
	<p>
		This method is slightly experimental. The way it works is to patch some universal location in the <code>d3d9.dll</code> module that accesses the device pointer 
		to JMP to a code cave, which then gets the vtable from the object and calls a callback function (<code>DirectX9Callback</code>) where the hooks are then 
		applied. The JMP patch is then removed.
	</p>
	<p>
		The code is explained below:
		<p>
		Step 1: Patch <code>d3d9.dll</code>
		</p>
		<p><pre><code>
		void InsertDirectX9Cave( void )
		{
			DWORD dwOldJump, dwOldCave, dwDx9Base = (DWORD)GetModuleHandle("d3d9.dll");
			DWORD *dwDx9Jump = (DWORD *)(dwDx9Base + 0x0B91B);
			DWORD *dwDx9Cave = (DWORD *)(dwDx9Base + 0x1A86DE);
			
			static DWORD  *pSetHookPtr = (DWORD *)DirectX9Callback;
			static DWORD  **pFuncPtr = &pSetHookPtr, *pTableAddress = (DWORD *)&pTable;

			UCHAR patch_jmp[]	= { 0xE9, 0xBE, 0xCD, 0x19, 0x00 };
			UCHAR patch_cave[]	= { 0x8B, 0x08, 0x8B, 0x51, 0x04, 0x50, 0x8B, 0x00, 0xA3,
									0x90, 0x90, 0x90, 0x90, 0xA1, 0x66, 0x66, 0x66, 0x66,
									0x60, 0xFF, 0xD0, 0x61, 0x58, 0xE9, 0x26, 0x32, 0xE6, 0xFF };

			memcpy((void *)((DWORD)patch_cave +  9), (void *)&pTableAddress, 4);
			memcpy((void *)((DWORD)patch_cave + 14), (void *)&pFuncPtr, 4);

			if(!VirtualProtect((void *)dwDx9Jump,  5, PAGE_EXECUTE_READWRITE, &dwOldJump) ||
			   !VirtualProtect((void *)dwDx9Cave, 28, PAGE_EXECUTE_READWRITE, &dwOldCave))
					return;

			memcpy((void *)dwDx9Cave, &patch_cave, 28);
			memcpy((void *)dwDx9Jump, &patch_jmp,   5);

			VirtualProtect((void *)dwDx9Jump,  5, dwOldJump, NULL);
			VirtualProtect((void *)dwDx9Cave, 21, dwOldCave, NULL);
		}
		</code></pre></p>
		<h4>
			ASM Listings:
		</h4>
		<p>
			The JMP patch:
		</p>
		<p><pre><code>
			67F46F20     E9 B9171A00    JMP d3d9.680E86DE
		</code></pre></p>
		</p>
		<p>
			The cave:
		</p>
		<p><pre><code>
			680E86DE   > 8B0E           MOV ECX,DWORD PTR DS:[ESI]			; original instruction
			680E86E0   . 8B51 04        MOV EDX,DWORD PTR DS:[ECX+4]		; original instruction
			680E86E3     50             PUSH EAX					; preserve register
			680E86E4     8BC6           MOV EAX,ESI					; ESI = device pointer
			680E86E6     8B00           MOV EAX,DWORD PTR DS:[EAX]			; [ESI+00] = vtable pointer
			680E86E8     A3 EFBEADDE    MOV DWORD PTR DS:[DEADBEEF],EAX		; replace deadbeef with &pVtable
			680E86ED     58             POP EAX					; restore register
			680E86EE    ^E9 32E8E5FF    JMP d3d9.67F46F25				; jmp back
		</code></pre></p>
		</p>
		<p>
		A possible issue is that the JMP locations will change accross DX versions, but my DirectX8 hook that works in the same way works on my new Windows 7 
		64-bit install, so maybe not.
		</p>
		<p>
		The ideal approach (that I can think of) would be to create a dummy <code>IDirect3DDevice9</code> object and use IT to find the vtable. I almsot got it 
		working but the dummy pointer has a different vtable.
	</p>
	
	<h3>3.3 Dynamic hook</h3>
	<p>
	If <code>d3d9.dll</code> has not been loaded yet, there is NO way that we can do any sort of DirectX hooking. This means that if the program loads 
	DirectX at all, it will do so using <code>LoadLibrary</code> and <code>GetProcAddress</code>. Using Illuzi0N's dynamic hooking method, we return our detoured 
	<code>Direct3DCreate9</code> from <code>GetProcAddress</code> so that it will be called instead of the original. Handle it like a STANDARD hook from there.
	</p>

  </body>
</html>